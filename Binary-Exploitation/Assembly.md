# Assembly

*Most of this content is from my notes of the course on [HTB Academy](https://academy.hackthebox.com/course/preview/intro-to-assembly-language) I really recommend it because the exercises they provide is a great way to understand in details Assembly. Also the GDB part is very useful for when you will exploit linux based Buffer Overflow*

## Architecture

![image](https://user-images.githubusercontent.com/96747355/166333892-9f6f7445-7305-4ef2-abd1-0864513e4e6d.png)  

![assembly](https://repository-images.githubusercontent.com/148274844/d37b5000-0de4-11ea-9e50-71d9622746f9)  

With registers we can:
- Transfer data between memory and register, and vice versa
- Perform arithmetic operations on registers and data
- Transfer control to other parts of the program

### Computer Architecture

Today Von Neuman Architecture.

This architecture executes machine code to perform specific algorithms. It mainly consists of the following elements:

- Central Processing Unit (CPU)
- Memory Unit
- Input/Output Devices
  - Mass Storage Unit
  - Keyboard
  - Display

Furthermore, the CPU itself consists of three main components:
- Control Unit (CU)
- Arithmetic/Logic Unit (ALU)
- Registers

Though very old, this architecture is still the basis of most modern computers, servers, and even smartphones.

![image](https://user-images.githubusercontent.com/96747355/166334003-938ccdcb-6fbc-4463-853e-0a9c08490924.png)  
*Image from Hackthebox Academy*  

#### RAM

![image](https://user-images.githubusercontent.com/96747355/166334168-869c63a3-e843-4be9-96cf-d84cdc42e074.png)
*Image from Hackthebox Academy*  

|Segment|Description|
|-------|-----------|
|Stack|Has a Last-in First-out (LIFO) design and is fixed in size. Data in it can only be accessed in a specific order by push-ing and pop-ing data.|
|Heap|Has a hierarchical design and is therefore much larger and more versatile in storing data, as data can be stored and retrieved in any order. However, this makes the heap slower than the Stack.|
|Data|Has two parts: Data, which is used to hold variables, and .bss, which is used to hold unassigned variables (i.e., buffer memory for later allocation).|
|Text|Main assembly instructions are loaded into this segment to be fetched and executed by the CPU.|

Although this segmentation applies to the entire RAM, each application is allocated its Virtual Memory when it is run. This means that each application would have its own stack, heap, data, and text segments.

### CPU Architecture

![image](https://user-images.githubusercontent.com/96747355/166334607-9f24cd51-13e6-4e23-ac24-391a006ef9bf.png)  
*Image from Hackthebox Academy*  

|Instruction|Description|
|-----------|-----------|
|1. Fetch|Takes the next instruction's address from the Instruction Address Register (IAR), which tells it where the next instruction is located.|
|2. Decode|Takes the instruction from the IAR, and decodes it from binary to see what is required to be executed.|
|3. Execute|Fetch instruction operands from register/memory, and process the instruction in the ALU or CU.|
|4. Store|Store the new value in the destination operand.|

![image](https://user-images.githubusercontent.com/96747355/166334865-148c4d60-2e13-4f8d-87c1-0be2def6ccd8.png)  
*Image from Hackthebox Academy*  

If we want to know whether our Linux system supports x86_64 architecture, we can use the lscpu command:
```
user ~ $ lscpu
Architecture :                          x86_64
Mode(s) op√©ratoire(s) des processeurs : 32-bit, 64-bit
Boutisme :                              Little Endian
```
```
user ~ $ uname -m
x86_64
```

### Instruction Set Architectures

An Instruction Set Architecture (ISA) specifies the syntax and semantics of the assembly language on each architecture. It is not just a different syntax but is built in the core design of a processor, as it affects the way and order instructions are executed and their level of complexity. ISA mainly consists of the following components:
- Instructions
- Registers
- Memory Addresses
- Data Types

|Component|Description|Example|
|---------|-----------|-------|
|Instructions|The instruction to be processed in the opcode operand_list format. There are usually 1,2, or 3 comma-separated operands.|`add rax, 1, mov rsp, rax, push rax`|
|Registers|Used to store operands, addresses, or instructions temporarily.|`rax, rsp, rip`|
|Memory Addresses|The address in which data or instructions are stored. May point to memory or registers.|`0xffffffffaa8a25ff, 0x44d0, $rax`|
|Data Types|The type of stored data.|`byte, word, double word`|

#### CISC vs RISC

![image](https://user-images.githubusercontent.com/96747355/166335428-b49267b9-3b8a-4474-b1b6-7262716d6794.png)  
*Image from Hackthebox Academy*  

|Area|CISC|RISC|
|----|----|----|
|Complexity|Favors complex instructions|Favors simple instructions|
|Length of instructions|Longer instructions - Variable length 'multiples of 8-bits'|Shorter instructions - Fixed length '32-bit/64-bit'|
|Total instructions per program|Fewer total instructions - Shorter code|More total instructions - Longer code|
|Optimization|Relies on hardware optimization (in CPU)|Relies on software optimization (in Assembly)|
|Instruction Execution Time|Variable - Multiple clock cycles|Fixed - One clock cycle|
|Instructions supported by CPU|Many instructions (~1500)|Fewer instructions (~200)|
|Power Consumption|High|Very low|
|Examples|Intel, AMD|ARM, Apple|


### Registers, Addresses and Data Types

#### Registers

There are two main types of registers we will be focusing on: Data Registers and Pointer Registers.

|Data Registers|Pointer Registers|
|--------------|-----------------|
|rax|rbp|
|rbx|rsp|
|rcx|rip|
|rdx||
|r8||
|r9||
|r10||

- Data Registers - are usually used for storing instructions/syscall arguments. The primary data registers are: rax, rbx, rcx, and rdx. The rdi and rsi registers also exist and are usually used for the instruction destination and source operands. Then, we have secondary data registers that can be used when all previous registers are in use, which are r8, r9, and r10.
Pointer Registers - are used to store specific important address pointers. The main pointer registers are the Base Stack Pointer rbp, which points to the beginning of the Stack, the Current Stack Pointer rsp, which points to the current location within the Stack (top of the Stack), and the Instruction - Pointer rip, which holds the address of the next instruction.
Sub-Registers
Each 64-bit register can be further divided into smaller sub-registers containing the lower bits, at one byte 8-bits, 2 bytes 16-bits, and 4 bytes 32-bits. Each sub-register can be used and accessed on its own, so we don't have to consume the full 64-bits if we have a smaller amount of data.

![image](https://user-images.githubusercontent.com/96747355/166336022-2d3594a5-4c3c-4612-8156-6187c81e09f6.png)  
*Image from Hackthebox Academy*  

Sub-registers can be accessed as:

|Size in bits|Size in bytes|Name|Example|
|------------|-------------|----|-------|
|16-bit|2 bytes|the base name|ax|
|8-bit|1 bytes|base name and/or ends with l|al|
|32-bit|4 bytes|base name + starts with the e prefix||eax|
|64-bit|8 bytes|base name + starts with the r prefix|rax|

The following are the names of the sub-registers for all of the essential registers in an x86_64 architecture:

|Description|64-bit Register|32-bit Register|16-bit Register|8-bit Register|
|-----------|---------------|---------------|---------------|--------------|
|Data/Arguments Registers|||||
|Syscall Number/Return value|rax|eax|ax|al|
|Callee Saved|rbx|ebx|bx|bl|
|1st arg - Destination operand|rdi|edi|di|dil|
|2nd arg - Source operand|rsi|esi|si|sil|
|3rd arg|rdx|edx|dx|dl|
|4th arg - Loop counter|rcx|ecx|cx|cl|
|5th arg|r8|r8d|r8w|r8b|
|6th arg|r9|r9d|r9w|r9b|
|Pointer Registers||||
|Base Stack Pointer|rbp|ebp|bp|bpl|
|Current/Top Stack Pointer|rsp|esp|sp|spl|
|Instruction Pointer 'call only'|rip|eip|ip|ipl|

#### Memory Addresses

Whenever an instruction goes through the Instruction Cycle to be executed, the first step is to fetch the instruction from the address it's located at, as previously discussed. There are several types of address fetching (i.e., addressing modes) in the x86 architecture:

|Addressing Mode|Description|Example|
|---------------|-----------|-------|
|Immediate|The value is given within the instruction|add 2|
|Register|The register name that holds the value is given in the instruction|add rax|
|Direct|The direct full address is given in the instruction|call 0xffffffffaa8a25ff|
|Indirect|A reference pointer is given in the instruction|call 0x44d000 or call [rax]|
|Stack|Address is on top of the stack|add rbp|

In the above table, lower is slower. The less immediate the value is, the slower it is to fetch it.


#### Endianess

The following table demonstrates how endianness works:  

![image](https://user-images.githubusercontent.com/96747355/166327711-527573f6-92e2-45ad-b56c-49517703b519.png)  
*Image from HTB Academy*  

#### Data Types

|Component|Length|Example|
|---------|------|-------|
|byte|8 bits|`0xab`|
|word|16 bits - 2 bytes|`0xabcd`|
|double word (dword)|32 bits - 4 bytes|`0xabcdef12`|
|quad word (qword)|64 bits - 8 bytes|`0xabcdef1234567890`|

The following table shows the appropriate data type for each sub-register:

|Sub-register|Data Type|
|------------|---------|
|al|byte|
|ax|word|
|eax|dword|
|rax|qword|

## Assembling & Debugging

### Assembly File Structure

![image](https://user-images.githubusercontent.com/96747355/166326495-5e51ee47-e79d-4668-9543-a0ef6c257c5d.png)  
*Image from HTB Academy*  

Next, if we look at the code line-by-line, we see that it has three main parts:

|Section|Description|
|-------|-----------|
|`global _start`|This is a directive that directs the code to start executing at the `_start` label defined below.
|section .data|This is the data section, which should contain all of the variables.|
|section .text|This is the text section containing all of the code to be executed.|

Both the .data and .text sections refer to the data and text memory segments, in which these instructions will be stored.

#### Variables

We can define variables using db for a list of bytes, dw for a list of words, dd for a list of digits, and so on. We can also label any of our variables so we can call it or reference it later. The following are some examples of defining variables:

|Instruction|Description|
|-----------|-----------|
|db 0x0a|Defines the byte 0x0a, which is a new line.|
|message db 0x41, 0x42, 0x43, 0x0a|Defines the label message => abc\n.|
|message db "Hello World!", 0x0a|Defines the label message => Hello World!\n.|


### Assembling & Disassembling

#### Assembling

- Hello world in assembly
```

global _start

section .data
   message db "Hello World!"
   length equ $-message

section .text
_start:
   mov rax, 1
   mov rdi, 1
   mov rsi, message
   mov rdx, length
   syscall

   mov rax, 60
   mov rdi, 0
   syscall
```

- Bash script to assemble link and run nasm

```
#!/bin/bash

# Bash script to assemble, link and run nasm
# Assembling: nasm -f elf64 helloWorld.s
# Linking: ld -o helloWorld helloWorld.o
# Run: ./helloWorld

fileName="${1%%.*}" # remove .s extension

nasm -f elf64 ${fileName}".s"
ld ${fileName}".o" -o ${fileName}
[ "$2" == "-g" ] && gdb -q ${fileName} || ./${fileName}
```

#### Disassembling

- `objdump -M intel -d binFileToDisassemble`

```
‚îå‚îÄ‚îÄ(kali„âøkali)-[~/Documents]
‚îî‚îÄ$ objdump -M intel -d helloWorld

helloWorld:     file format elf64-x86-64


Disassembly of section .text:

0000000000401000 <_start>:
 401000:       b8 01 00 00 00          mov    eax,0x1
 401005:       bf 01 00 00 00          mov    edi,0x1
 40100a:       48 be 00 20 40 00 00    movabs rsi,0x402000
 401011:       00 00 00
 401014:       ba 12 00 00 00          mov    edx,0x12
 401019:       0f 05                   syscall
 40101b:       b8 3c 00 00 00          mov    eax,0x3c
 401020:       bf 00 00 00 00          mov    edi,0x0
 401025:       0f 05                   syscall
```

- If we wanted to only show the assembly code, without machine code or addresses, we could add the --no-show-raw-insn --no-addresses
The -d flag will only disassemble the .text section of our code. To dump any strings, we can use the -s flag, and add -j .data to only examine the .data section. This means that we also do not need to add -M intel.

- `objdump -sj .data binFileToDisassemble`
```

‚îå‚îÄ‚îÄ(kali„âøkali)-[~/Documents]
‚îî‚îÄ$ objdump -sj .data helloWorld

helloWorld:     file format elf64-x86-64

Contents of section .data:
402000 48656c6c 6f204854 42204163 6164656d  Hello HTB Academ
402010 7921                                 y!   
```


### GNU Debbugger (GDB)

One of the great features of GDB is its support for third-party plugins. An excellent plugin that is well maintained and has good documentation is GEF. GEF is a free and open-source GDB plugin that is built precisely for reverse engineering and binary exploitation. This fact makes it a great tool to learn.
```
$ wget -O ~/.gdbinit-gef.py -q https://github.com/hugsy/gef/raw/master/gef.py
$ echo source ~/.gdbinit-gef.py >> ~/.gdbinit
```
Going forward, we will frequently be assembling and linking our assembly code and then running it with gdb. To do so quickly, we can use the assembler.sh script we wrote in the previous section with the -g flag. It will assemble and link the code, and then run it with gdb, as follows:
```
./assembler.sh helloWorld.s -g
```
```

‚îå‚îÄ‚îÄ(kali„âøkali)-[~/Documents/intro-to-assembly]
‚îî‚îÄ$ ./assembler.sh helloWorld.s -g
GEF for linux ready, type `gef' to start, `gef config' to configure
93 commands loaded for GDB 10.1.90.20210103-git using Python engine 3.9
[*] 3 commands could not be loaded, run `gef missing` to know why.
Reading symbols from helloWorld...
(No debugging symbols found in helloWorld)
gef‚û§ 
```

#### Info

```
gef‚û§  help info
info, inf, i
Generic command for showing things about the program being debugged.
```

#### Functions

```
gef‚û§  info functions
All defined functions:

Non-debugging symbols:
0x0000000000401000  _start
```

#### Variables

```
gef‚û§  info variables
All defined variables:

Non-debugging symbols:
0x0000000000402000  message
0x0000000000402012  __bss_start
0x0000000000402012  _edata
0x0000000000402018  _end
```

#### Disassemble

To view the instructions within a specific function, we can use the disassemble or disas command along with the function name

```
gef‚û§  disas _start
Dump of assembler code for function _start:
  0x0000000000401000 <+0>:     mov    eax,0x1
  0x0000000000401005 <+5>:     mov    edi,0x1
  0x000000000040100a <+10>:    movabs rsi,0x402000
  0x0000000000401014 <+20>:    mov    edx,0x12
  0x0000000000401019 <+25>:    syscall
  0x000000000040101b <+27>:    mov    eax,0x3c
  0x0000000000401020 <+32>:    mov    edi,0x0
  0x0000000000401025 <+37>:    syscall
End of assembler dump.
```

### Debug with GDB

| Step | Description |
|------|-------------|
|Break |Setting breakpoints at various points of interest|
|Examine|Running the program and examining the state of the program at these points|
|Step|Moving through the program to examine how it acts with each instruction and with user input|
|Modify|Modify values in specific registers or addresses at specific breakpoints, to study how it would affect the execution|

#### Break

We can set a breakpoint at a specific address or for a particular function. To set a breakpoint, we can use the break or b command along with the address or function name we want to break at.

```
gef‚û§  b _start
Breakpoint 1 at 0x401000
```
Now, in order to start our program, we can use the run or r command.
```
gef‚û§  run
Starting program: /home/kali/Documents/intro-to-assembly/helloWorld
[STRIPPED]
‚Üí   0x401000 <_start+0>       mov    eax, 0x1
[STRIPPED]
```
The breakpoint is set where the arrow is.  
If we want to set a breakpoint at a certain address, like `_start+10`, we can either `b _start+10` or `b *0x40100a`.
The `*` tells GDB to break at the instruction stored in `0x40100a`.
If we want to see what breakpoints we have at any point of the execution, we can use the info breakpoint command. We can also disable, enable, or delete any breakpoint. Furthermore, GDB also supports setting conditional breaks that stop the execution when a specific condition is met.

#### Examine

To manually examine any of the addresses or registers or examine any other, we can use the x command in the format of x/FMT ADDRESS, as help x would tell us. The ADDRESS is the address or register we want to examine, while FMT is the examine format. The examine format FMT can have three parts:  
![image](https://user-images.githubusercontent.com/96747355/166330346-ee3232a5-c103-4653-987a-dcfd2cca8f3b.png)  
*Image from Hackthebox Academy*

#### Instructions

For example, if we wanted to examine the next four instructions in line, we will have to examine the $rip register (which holds the address of the next instruction), and use 4 for the count, i for the format, and g for the size (for 8-bytes or 64-bits). So, the final examine command would be x/4ig $rip

```
gef‚û§  x/4ig $rip
=> 0x401000 <_start>:   mov    eax,0x1
  0x401005 <_start+5>: mov    edi,0x1
  0x40100a <_start+10>:        movabs rsi,0x402000
  0x401014 <_start+20>:        mov    edx,0x12
```

#### Strings

We can also examine a variable stored at a specific memory address. We know that our message variable is stored at the .data section on address 0x402000 from our previous disassembly. We also see the upcoming command movabs rsi, 0x402000, so we may want to examine what is being moved from 0x402000.

In this case, we will not put anything for the Count, as we only want one address (1 is the default), and will use s as the format to get it in a string format rather than in hex
```
gef‚û§  x/s 0x402000
0x402000:       "Hello HTB Academy!"
```

#### Addresses

The most common format of examining is hex x. We often need to examine addresses and registers containing hex data, such as memory addresses, instructions, or binary data. Let us examine the same previous instruction, but in hex format, to see how it looks
```
gef‚û§  x/wx 0x401000
0x401000 <_start>:      0x000001b8
```
We see instead of mov eax,0x1, we get 0x000001b8, which is the hex representation of the mov eax,0x1 machine code in little-endian formatting.
- This is read as: `b8 01 00 00`.  

We can also use GEF features to examine certain addresses. For example, at any point we can use the registers command to print out the current value of all registers.

#### Step

To move through the program, there are three different commands we can use: stepi and step.


##### Step instruction

The `stepi` or `si` command will step through the assembly instructions one by one, which is the smallest level of steps possible while debugging.

##### Step Count

Similarly to examine, we can repeat the si command by adding a number after it. For example, if we wanted to move 3 steps to reach the syscall instruction, we can do `si 3`
You can hit the `return/enter empty` in order to repeat the last command

##### Step

The `step` or `s` command, on the other hand, will continue until the following line of code is reached or until it exits from the current function.

If there's a call to another function within this function, it'll break at the beginning of that function. Otherwise, it'll break after we exit this function after the program's end.

There's also the next or n command, which will also continue until the next line, but will skip any functions called in the same line of code, instead of breaking at them like step. There's also the nexti or ni, which is similar to si, but skips functions calls.

#### Modify

##### Addresses

To modify values in GDB, we can use the set command. However, we will utilize the patch command in GEF to make this step much easier.

We have to provide the type/size of the new value, the location to be stored, and the value we want to use.

```
gef‚û§  patch string 0x402000 "Patched!\\x0a"
gef‚û§  c
Continuing.
Patched!
Academy![Inferior 1 (process 3824) exited normally]
```
We see that we successfully modified the string and got Patched!\n Academy! instead of the old string. Notice how we used \x0a for adding a new line after our string.

## Basic Instructions

### Data Movement

|Instruction|Description|Example|
|-----------|-----------|-------|
|mov|Move data or load immediate data|`mov rax, 1 -> rax = 1`|
|lea|Load an address pointing to the value|`lea rax, [rsp+5] -> rax = rsp+5`|
|xchg|Swap data between two registers or addresses|`xchg rax, rbx -> rax = rbx, rbx = rax`|

#### Loading Data

We can load immediate data using the mov instruction. For example, we can load the value of 1 into the rax register using the mov rax, 1 instruction. We have to remember here that the size of the loaded data depends on the size of the destination register. For example, in the above mov rax, 1 instruction, since we used the 64-bit register rax, it will be moving a 64-bit representation of the number 1 (i.e. 0x00000001), which is not very efficient.

This is why it is more efficient to use a register size that matches our data size. For example, we will get the same result as the above example if we use mov al, 1, since we are moving 1-byte (0x01) into a 1-byte register (al), which is much more efficient.

The xchg instruction will swap the data between the two registers.

#### Address Pointers

Another critical concept to understand is using pointers. In many cases, we would see that the register or address we are using does not immediately contain the final value but contains another address that points to the final value. This is always the case with pointer registers, like rsp, rbp, and rip, but is also used with any other register or memory address.

We can use square brackets to compute an address offset relative to a register or another address. For example, we can do mov rax, [rsp+10] to move the value stored 10 address away from rsp.

#### Moving pointer values

To move the actual value, we will have to use square brackets [], which in x86_64 assembly and Intel syntax means load value at address.

Note: When using [], we may need to set the data size before the square brackets, like byte or qword. However, in most cases, nasm will automatically do that for us. We can see above that the final instruction is actually mov rax, QWORD PTR [rsp]. We also see that nasm also added PTR to specify moving a value from a pointer.

#### Loading value pointers

Finally, we need to understand how to load a pointer address to a value, using the lea (or Load Effective Address) instruction, which loads a pointer to the specified value, as in lea rax, [rsp]. This is the opposite of what we just learned above (i.e., load pointer to a value vs. move value from pointer).

### Arithmetic instructions

The second type of basic instructions is Arithmetic Instructions. With Arithmetic Instructions, we can perform various mathematical computations on data stored in registers and memory addresses. These instructions are usually processed by the ALU in the CPU, among other instructions. We will split arithmetic instructions into two types: instructions that take only one operand (Unary), instructions that take two operands (Binary).

#### Unary Instructions

|Instruction|Description|Example|
|-----------|-----------|-------|
|inc|Increment by 1|`inc rax -> rax++ or rax += 1 -> rax = 2`|
|dec|Decrement by 1|`dec rax -> rax-- or rax -= 1 -> rax = 0`|

#### Binary Instructions

|Instruction|Description|Example|
|-----------|-----------|-------|
|add|Add both operands|`add rax, rbx -> rax = 1 + 1 -> 2`|
|sub|Subtract Source from Destination (i.e rax = rax - rbx)|`sub rax, rbx -> rax = 1 - 1 -> 0`|
|imul|Multiply both operands|`imul rax, rbx -> rax = 1 * 1 -> 1`|

Note that in all of the above instructions, the result is always stored in the destination operand, while the source operand is not affected.

#### Bitwise Instructions

|Instruction|Description|Example|
|-----------|-----------|-------|
|not|Bitwise NOT (invert all bits, 0->1 and 1->0)|`not rax -> NOT 00000001 -> 11111110`|
|and|Bitwise AND (if both bits are 1 -> 1, if bits are different -> 0)|`and rax, rbx -> 00000001 AND 00000010 -> 00000000`|
|or|Bitwise OR (if either bit is 1 -> 1, if both are 0 -> 0)|`or rax, rbx -> 00000001 OR 00000010 -> 00000011`|
|xor|Bitwise XOR (if bits are the same -> 0, if bits are different -> 1)|`xor rax, rbx -> 00000001 XOR 00000010 -> 00000011`

## Control Instructions

### Loops

This is where Control instructions come in. Such instructions allow us to change the flow of the program and direct it to another line.
Other types of Control Instructions include: Loops, Branching, Function Calls

#### Loop Structure

A loop in assembly is a set of instructions that repeat for rcx times.

|Instruction|Description|Example|
|-----------|-----------|-------|
|mov rcx, x|Sets loop (rcx) counter to x|`mov rcx, 3`|
|loop|Jumps back to the start of loop until counter reaches 0|`loop exampleLoop`|

### Unconditional Branching

The second type of Control Instructions is Branching Instructions, which are general instructions that allow us to jump to any point in the program if a specific condition is met.

#### JMP

|Instruction|Description|Example|
|-----------|-----------|-------|
|jmp|Jumps to specified label, address, or location|jmp loop|

### Conditional Branching

Unlike Unconditional Branching Instructions, Conditional Branching instructions are only processed when a specific condition is met, based on the Destination and Source operands. A conditional jump instruction has multiple varieties as Jcc, where cc represents the Condition Code. The following are some of the main condition codes:

|Instruction|Condition|Description|
|-----------|---------|-----------|
|jz|D = 0|Destination equal to Zero|
|jnz|D != 0|Destination Not equal to Zero|
|js|D < 0|Destination is Negative|
|jns|D >= 0|Destination is Not Negative (i.e. 0 or positive)|
|jg|D > S|Destination Greater than Source|
|jge|D >= S|Destination Greater than or Equal Source|
|jl|D < S|Destination Less than Source|
|jle|D <= S|Destination Less than or Equal Source|

There are many other similar conditions that we can utilize as well. For a complete list of conditions, we can refer to the latest [Intel x86_64 manual](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf), in the Jcc-Jump if Condition Is Met section. Conditional instructions are not restricted to jmp instructions only but are also used with other assembly instructions for conditional use as well, like the CMOVcc and SETcc instructions.

For example, if we wanted to perform a mov rax, rbx instruction, but only if the condition is = 0, then we can use the CMOVcc or conditional mov instruction, such as cmovz rax, rbx instruction. Similarly, if we wanted to move if the condition is <, then we can use the cmovl rax, rbx instruction, and so on for other conditions. The same applies to the set instruction, which sets the operand's byte to 1 if the condition is met or 1 otherwise. An example of this is setz rax.

#### RFLAGS Registers

We have been talking about meeting certain conditions, but we have not yet discussed how these conditions are met or where they are stored. This is where we use the RFLAGS register, which we briefly mentioned in the Registers section.

The RFLAGS register consists of 64-bits like any other register. However, this register does not hold values but holds flag bits instead. Each bit 'or set of bits' turns to 1 or 0 depending on the value of the last instruction.

![image](https://user-images.githubusercontent.com/96747355/166338913-967a73cd-9678-47ef-8ccd-af0b81544522.png)  

- The Carry Flag CF: Indicates whether we have a float.
- The Parity Flag PF: Indicates whether a number is odd or even.
- The Zero Flag ZF: Indicates whether a number is zero.
- The Sign Flag SF: Indicates whether a register is negative.

#### JNZ

#### CMP

The Compare instruction cmp simply compares the two operands, by subtracting the second operand from first operand (i.e. D1 - S2), and then sets the necessary flags in the RFLAGS register. For example, if we use cmp rbx, 10, then the compare instruction would do 'rbx - 10', and set the flags based on the result.

|Instruction|Description|Example|
|-----------|-----------|-------|
|cmp|Sets RFLAGS by subtracting second operand from first operand (i.e. first - second)|cmp rax, rbx -> rax - rbx|

## Functions

### Using the stack

COMING SOON!

## Assembly Syntax Cheat Sheet

- `movq source, destination`
- `addq source, destination`
- `subq source, destination`
- `imulq source, destination`
- `salq source, destination`
- `sarq source, destination`
- `xorq source, destination`
- `andq source, destination`
- `orq source, destination`

## Resources

{% embed url="https://academy.hackthebox.com/course/preview/intro-to-assembly-language" %} Intro to Assembly Language - HTB Academy {% endembed %}

